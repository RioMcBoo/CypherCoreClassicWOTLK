// Copyright (c) CypherCore <http://github.com/CypherCore> All rights reserved.
// Licensed under the GNU GENERAL PUBLIC LICENSE. See LICENSE file in the project root for full license information.

using Framework.Constants;
using Framework.Database;
using Game.BattlePets;
using Game.DataStorage;
using Game.Entities;
using Game.Networking;
using Game.Networking.Packets;
using System;
using System.Collections.Generic;

namespace Game
{
    public partial class WorldSession
    {
        [WorldPacketHandler(ClientOpcodes.SplitItem, Processing = PacketProcessing.Inplace)]
        void HandleSplitItem(SplitItem splitItem)
        {
            if (splitItem.Inv.Items.Count != 0)
            {
                Log.outError(LogFilter.Network, 
                    $"WORLD: HandleSplitItemOpcode - Invalid itemCount ({splitItem.Inv.Items.Count})");
                return;
            }

            ItemPos src = new(splitItem.FromSlot, splitItem.FromPackSlot);
            ItemPos dst = new(splitItem.ToSlot, splitItem.ToPackSlot);

            if (src == dst)
                return;

            if (splitItem.Quantity == 0)
                return;                                             //check count - if zero it's fake packet

            if (!_player.IsValidPos(src, true))
            {
                _player.SendEquipError(InventoryResult.ItemNotFound);
                return;
            }

            if (!_player.IsValidPos(dst, false))       // can be autostore pos
            {
                _player.SendEquipError(InventoryResult.WrongSlot);
                return;
            }

            _player.SplitItem(src, dst, splitItem.Quantity);
        }

        [WorldPacketHandler(ClientOpcodes.SwapInvItem, Processing = PacketProcessing.Inplace)]
        void HandleSwapInvenotryItem(SwapInvItem swapInvItem)
        {
            if (swapInvItem.Inv.Items.Count != 2)
            {
                Log.outError(LogFilter.Network, 
                    $"WORLD: HandleSwapInvItemOpcode - Invalid itemCount ({swapInvItem.Inv.Items.Count})");
                return;
            }

            ItemPos src = swapInvItem.SourceSlot;
            ItemPos dst = swapInvItem.DestinationSlot;

            // prevent attempt swap same item to current position generated by client at special checting sequence
            if (swapInvItem.SourceSlot == swapInvItem.DestinationSlot)
                return;

            if (!GetPlayer().IsValidPos(src, true))
            {
                GetPlayer().SendEquipError(InventoryResult.ItemNotFound);
                return;
            }

            if (!GetPlayer().IsValidPos(dst, true))
            {
                GetPlayer().SendEquipError(InventoryResult.WrongSlot);
                return;
            }

            if ((src.IsBankPos || dst.IsBankPos) && !CanUseBank())
            {
                Log.outDebug(LogFilter.Network, 
                    $"WORLD: HandleSwapInvItemOpcode - {_player.PlayerTalkClass.GetInteractionData().SourceGuid} " +
                    $"not found or you can't interact with him.");
                return;
            }

            GetPlayer().SwapItem(src, dst);
        }

        [WorldPacketHandler(ClientOpcodes.AutoEquipItemSlot, Processing = PacketProcessing.Inplace)]
        void HandleAutoEquipItemSlot(AutoEquipItemSlot packet)
        {
            ItemPos dstPos = packet.ItemDstSlot;
            ItemPos srcPos = new(packet.Inv.Items[0].Container, packet.Inv.Items[0].Slot);

            // cheating attempt, client should never send opcode in that case
            if (packet.Inv.Items.Count != 1 || !dstPos.IsEquipmentPos)
                return;

            Item item = GetPlayer().GetItemByGuid(packet.Item);            

            if (item == null || item.InventoryPosition != srcPos || srcPos == dstPos)
                return;

            GetPlayer().SwapItem(srcPos, dstPos);
        }

        [WorldPacketHandler(ClientOpcodes.SwapItem, Processing = PacketProcessing.Inplace)]
        void HandleSwapItem(SwapItem swapItem)
        {
            if (swapItem.Inv.Items.Count != 2)
            {
                Log.outError(LogFilter.Network, 
                    $"WORLD: HandleSwapItem - Invalid itemCount ({swapItem.Inv.Items.Count})");
                return;
            }

            ItemPos src = new(swapItem.SlotA, swapItem.ContainerSlotA);
            ItemPos dst = new(swapItem.SlotB, swapItem.ContainerSlotB);

            var player = GetPlayer();

            // prevent attempt swap same item to current position generated by client at special checting sequence
            if (src == dst)
                return;

            if (!player.IsValidPos(src, true))
            {
                player.SendEquipError(InventoryResult.ItemNotFound);
                return;
            }

            if (!player.IsValidPos(dst, true))
            {
                player.SendEquipError(InventoryResult.WrongSlot);
                return;
            }

            if ((src.IsBankPos || dst.IsBankPos) && !CanUseBank())
            {
                Log.outDebug(LogFilter.Network, 
                    $"WORLD: HandleSwapInvItemOpcode - {_player.PlayerTalkClass.GetInteractionData().SourceGuid} " +
                    $"not found or you can't interact with him.");
                return;
            }

            player.SwapItem(src, dst);
        }

        [WorldPacketHandler(ClientOpcodes.AutoEquipItem, Processing = PacketProcessing.Inplace)]
        void HandleAutoEquipItem(AutoEquipItem autoEquipItem)
        {
            if (autoEquipItem.Inv.Items.Count != 1)
            {
                Log.outError(LogFilter.Network, 
                    $"WORLD: HandleAutoEquipItem - Invalid itemCount ({autoEquipItem.Inv.Items.Count}).");
                return;
            }

            var player = GetPlayer();
            var src = new ItemPos(autoEquipItem.Slot, autoEquipItem.PackSlot);

            var srcItem = player.GetItemByPos(src);
            if (srcItem == null)
                return;                                             // only at cheat

            InventoryResult msg = player.CanEquipItem(ItemSlot.Null, out ItemPos dest, srcItem, !srcItem.IsBag());
            if (msg != InventoryResult.Ok)
            {
                player.SendEquipError(msg, srcItem);
                return;
            }

            if (dest == src)                                           // prevent equip in same slot, only at cheat
                return;

            var dstItem = player.GetItemByPos(dest);
            if (dstItem == null)                                         // empty slot, simple case
            {
                player.RemoveItem(src, true);
                player.EquipItem(dest, srcItem, true);

                player.AutoUnequipOffhandIfNeed();
            }
            else                                                    // have currently equipped item, not simple case
            {
                msg = player.CanUnequipItem(dest, !srcItem.IsBag());
                if (msg != InventoryResult.Ok)
                {
                    player.SendEquipError(msg, dstItem);
                    return;
                }

                if (!dstItem.HasItemFlag(ItemFieldFlags.Child))
                {
                    // check dest->src move possibility
                    List<(ItemPos item, int count)> sSrc = new();                    
                    if (src.IsInventoryPos)
                    {
                        msg = player.CanStoreItem(src, out sSrc, dstItem, forSwap: true);
                        if (msg != InventoryResult.Ok)
                            msg = player.CanStoreItem(new(ItemSlot.Null, src.Container), out sSrc, dstItem, forSwap: true);
                        if (msg != InventoryResult.Ok)
                            msg = player.CanStoreItem(ItemPos.Undefined, out sSrc, dstItem, forSwap: true);
                    }
                    else if (src.IsBankPos)
                    {
                        msg = player.CanBankItem(src, out sSrc, dstItem, true);
                        if (msg != InventoryResult.Ok)
                            msg = player.CanBankItem(new(ItemSlot.Null, src.Container), out sSrc, dstItem, true);
                        if (msg != InventoryResult.Ok)
                            msg = player.CanBankItem(ItemPos.Undefined, out sSrc, dstItem, true);
                    }
                    else if (src.IsEquipmentPos)
                    {
                        msg = player.CanEquipItem(autoEquipItem.Slot, out sSrc, dstItem, true);
                        if (msg == InventoryResult.Ok)
                            msg = player.CanUnequipItem(sSrc, true);
                    }

                    if (msg != InventoryResult.Ok)
                    {
                        player.SendEquipError(msg, dstItem, srcItem);
                        return;
                    }

                    // now do moves, remove...
                    player.RemoveItem(dest, false);
                    player.RemoveItem(src, false);

                    // add to dest
                    player.EquipItem(dest, srcItem, true);

                    // add to src
                    if (src.IsInventoryPos)
                        player.StoreItem(sSrc, dstItem, true);
                    else if (src.IsBankPos)
                        player.BankItem(sSrc, dstItem, true);
                    else if (src.IsEquipmentPos)
                        player.EquipItem(sSrc, dstItem, true);
                }
                else
                {
                    var parentItem = _player.GetItemByGuid(dstItem.GetCreator());
                    if (parentItem != null)
                    {
                        if (dest.IsEquipmentPos)
                        {
                            // dest is now empty
                            _player.SwapItem(src, dest);
                            // src is now empty
                            _player.SwapItem(parentItem.InventoryPosition, src);
                        }
                    }
                }

                player.AutoUnequipOffhandIfNeed();

                // if inventory item was moved, check if we can remove dependent auras, because they were not removed in Player::RemoveItem (update was set to false)
                // do this after swaps are done, we pass nullptr because both weapons could be swapped and none of them should be ignored
                if (src.IsEquipmentPos || dest.IsEquipmentPos)
                    player.ApplyItemDependentAuras(null, false);
            }
        }

        [WorldPacketHandler(ClientOpcodes.DestroyItem, Processing = PacketProcessing.Inplace)]
        void HandleDestroyItem(DestroyItem destroyItem)
        {
            ItemPos itemPos = new(destroyItem.SlotNum, destroyItem.ContainerId);

            // prevent drop unequipable items (in combat, for example) and non-empty bags
            if (itemPos.IsEquipmentPos || itemPos.IsBagSlotPos)
            {
                InventoryResult msg = _player.CanUnequipItem(itemPos, false);
                if (msg != InventoryResult.Ok)
                {
                    _player.SendEquipError(msg, _player.GetItemByPos(itemPos));
                    return;
                }
            }
                        
            Item pItem = _player.GetItemByPos(itemPos);
            if (pItem == null)
            {
                _player.SendEquipError(InventoryResult.ItemNotFound);
                return;
            }

            if (pItem.GetTemplate().HasFlag(ItemFlags.NoUserDestroy))
            {
                _player.SendEquipError(InventoryResult.DropBoundItem);
                return;
            }

            if (destroyItem.Count != 0)
            {
                int i_count = destroyItem.Count;
                _player.DestroyItemCount(pItem, ref i_count, true);
            }
            else
                _player.DestroyItem(itemPos, true);
        }

        [WorldPacketHandler(ClientOpcodes.ReadItem, Processing = PacketProcessing.Inplace)]
        void HandleReadItem(ReadItem readItem)
        {
            ItemPos itemPos = new(readItem.Slot, readItem.PackSlot);
            Item item = _player.GetItemByPos(itemPos);
            if (item != null && item.GetTemplate().GetPageText() != 0)
            {
                InventoryResult msg = _player.CanUseItem(item);
                if (msg == InventoryResult.Ok)
                {
                    ReadItemResultOK packet = new();
                    packet.Item = item.GetGUID();
                    SendPacket(packet);
                }
                else
                {
                    // @todo: 6.x research new values
                    /*WorldPackets.Item.ReadItemResultFailed packet;
                    packet.Item = item.GetGUID();
                    packet.Subcode = ??;
                    packet.Delay = ??;
                    SendPacket(packet);*/

                    Log.outInfo(LogFilter.Network, "STORAGE: Unable to read item");
                    _player.SendEquipError(msg, item);
                }
            }
            else
                _player.SendEquipError(InventoryResult.ItemNotFound);
        }

        [WorldPacketHandler(ClientOpcodes.SellItem, Processing = PacketProcessing.Inplace)]
        void HandleSellItem(SellItem packet)
        {
            if (packet.ItemGUID.IsEmpty())
                return;

            var pl = GetPlayer();

            Creature creature = pl.GetNPCIfCanInteractWith(packet.VendorGUID, NPCFlags1.Vendor, NPCFlags2.None);
            if (creature == null)
            {
                Log.outDebug(LogFilter.Network, 
                    $"WORLD: HandleSellItemOpcode - {packet.VendorGUID} " +
                    $"not found or you can not interact with him.");
                pl.SendSellError(SellResult.CantFindVendor, null, packet.ItemGUID);
                return;
            }

            if (creature.GetCreatureTemplate().FlagsExtra.HasFlag(CreatureFlagsExtra.NoSellVendor))
            {
                _player.SendSellError(SellResult.CantSellToThisMerchant, creature, packet.ItemGUID);
                return;
            }

            // remove fake death
            if (pl.HasUnitState(UnitState.Died))
                pl.RemoveAurasByType(AuraType.FeignDeath);

            Item pItem = pl.GetItemByGuid(packet.ItemGUID);
            if (pItem != null)
            {
                // prevent sell not owner item
                if (pl.GetGUID() != pItem.GetOwnerGUID())
                {
                    pl.SendSellError(SellResult.CantSellItem, creature, packet.ItemGUID);
                    return;
                }

                // prevent sell non empty bag by drag-and-drop at vendor's item list
                if (pItem.IsNotEmptyBag())
                {
                    pl.SendSellError(SellResult.CantSellItem, creature, packet.ItemGUID);
                    return;
                }

                // prevent sell currently looted item
                if (pl.GetLootGUID() == pItem.GetGUID())
                {
                    pl.SendSellError(SellResult.CantSellItem, creature, packet.ItemGUID);
                    return;
                }

                // prevent selling item for sellprice when the item is still refundable
                // this probably happens when right clicking a refundable item, the client sends both
                // CMSG_SELL_ITEM and CMSG_REFUND_ITEM (unverified)
                if (pItem.IsRefundable())
                    return; // Therefore, no feedback to client

                // special case at auto sell (sell all)
                if (packet.Amount == 0)
                    packet.Amount = pItem.GetCount();
                else
                {
                    // prevent sell more items that exist in stack (possible only not from client)
                    if (packet.Amount > pItem.GetCount())
                    {
                        pl.SendSellError(SellResult.CantSellItem, creature, packet.ItemGUID);
                        return;
                    }
                }

                ItemTemplate pProto = pItem.GetTemplate();
                if (pProto != null)
                {
                    if (pProto.GetSellPrice() > 0)
                    {
                        long money = pProto.GetSellPrice() * packet.Amount;

                        if (!_player.ModifyMoney(money)) // ensure player doesn't exceed gold limit
                        {
                            _player.SendSellError(SellResult.CantSellItem, creature, packet.ItemGUID);
                            return;
                        }

                        _player.UpdateCriteria(CriteriaType.MoneyEarnedFromSales, money);
                        _player.UpdateCriteria(CriteriaType.SellItemsToVendors, 1);

                        if (packet.Amount < pItem.GetCount())               // need split items
                        {
                            Item pNewItem = pItem.CloneItem(packet.Amount, pl);
                            if (pNewItem == null)
                            {
                                Log.outError(LogFilter.Network, 
                                    $"WORLD: HandleSellItemOpcode - could not create clone of item {pItem.GetEntry()}; " +
                                    $"count = {packet.Amount}");
                                pl.SendSellError(SellResult.CantSellItem, creature, packet.ItemGUID);
                                return;
                            }

                            pItem.SetCount(pItem.GetCount() - packet.Amount);
                            pl.ItemRemovedQuestCheck(pItem.GetEntry(), packet.Amount);
                            if (pl.IsInWorld)
                                pItem.SendUpdateToPlayer(pl);
                            pItem.SetState(ItemUpdateState.Changed, pl);

                            pl.AddItemToBuyBackSlot(pNewItem);
                            if (pl.IsInWorld)
                                pNewItem.SendUpdateToPlayer(pl);
                        }
                        else
                        {
                            pl.RemoveItem(pItem.InventoryPosition, true);
                            pl.ItemRemovedQuestCheck(pItem.GetEntry(), pItem.GetCount());
                            Item.RemoveItemFromUpdateQueueOf(pItem, pl);
                            pl.AddItemToBuyBackSlot(pItem);
                        }
                    }
                    else
                        pl.SendSellError(SellResult.CantSellItem, creature, packet.ItemGUID);
                    return;
                }
            }
            pl.SendSellError(SellResult.CantSellItem, creature, packet.ItemGUID);
            return;
        }

        [WorldPacketHandler(ClientOpcodes.BuyBackItem, Processing = PacketProcessing.Inplace)]
        void HandleBuybackItem(BuyBackItem packet)
        {
            Creature creature = _player.GetNPCIfCanInteractWith(packet.VendorGUID, NPCFlags1.Vendor, NPCFlags2.None);
            if (creature == null)
            {
                Log.outDebug(LogFilter.Network, 
                    $"WORLD: HandleBuybackItem - {packet.VendorGUID} " +
                    $"not found or you can not interact with him.");

                _player.SendSellError(SellResult.CantFindVendor, null, ObjectGuid.Empty);
                return;
            }

            // remove fake death
            if (_player.HasUnitState(UnitState.Died))
                _player.RemoveAurasByType(AuraType.FeignDeath);

            Item pItem = _player.GetItemFromBuyBackSlot(packet.Slot);
            if (pItem != null)
            {
                uint price = _player.m_activePlayerData.BuybackPrice[packet.Slot - InventorySlots.BuyBackStart];
                if (!_player.HasEnoughMoney(price))
                {
                    _player.SendBuyError(BuyResult.NotEnoughtMoney, creature, pItem.GetEntry());
                    return;
                }

                InventoryResult msg = _player.CanStoreItem(ItemPos.Undefined, out var dest, pItem);
                if (msg == InventoryResult.Ok)
                {
                    _player.ModifyMoney(-price);
                    _player.RemoveItemFromBuyBackSlot(packet.Slot, false);
                    _player.ItemAddedQuestCheck(pItem.GetEntry(), pItem.GetCount());
                    _player.StoreItem(dest, pItem, true);
                }
                else
                    _player.SendEquipError(msg, pItem);
                return;
            }
            else
                _player.SendBuyError(BuyResult.CantFindItem, creature, 0);
        }

        [WorldPacketHandler(ClientOpcodes.BuyItem, Processing = PacketProcessing.Inplace)]
        void HandleBuyItem(BuyItem packet)
        {
            // client expects count starting at 1, and we send vendorslot+1 to client already
            if (packet.Muid > 0)
                --packet.Muid;
            else
                return; // cheating

            switch (packet.ItemType)
            {
                case ItemVendorType.Item:
                    Item bagItem = GetPlayer().GetItemByGuid(packet.ContainerGUID);

                    ItemSlot bag = ItemSlot.Null;
                    if (bagItem != null && bagItem.IsBag())
                        bag = bagItem.InventorySlot;
                    else if (packet.ContainerGUID == GetPlayer().GetGUID()) // The client sends the player guid when trying to store an item in the default backpack
                        bag = ItemSlot.Null;

                    GetPlayer().BuyItemFromVendorSlot(packet.VendorGUID, packet.Muid, packet.Item.ItemID, (byte)packet.Quantity, new((ItemSlot)packet.Slot, bag));
                    break;
                case ItemVendorType.Currency:
                    GetPlayer().BuyCurrencyFromVendorSlot(packet.VendorGUID, packet.Muid, packet.Item.ItemID, (byte)packet.Quantity);
                    break;
                default:
                    Log.outDebug(LogFilter.Network, 
                        $"WORLD: received wrong itemType {packet.ItemType} in HandleBuyItem");
                    break;
            }
        }

        [WorldPacketHandler(ClientOpcodes.AutoStoreBagItem, Processing = PacketProcessing.Inplace)]
        void HandleAutoStoreBagItem(AutoStoreBagItem packet)
        {
            if (!packet.Inv.Items.Empty())
            {
                Log.outError(LogFilter.Network, 
                    $"HandleAutoStoreBagItemOpcode - Invalid itemCount ({packet.Inv.Items.Count})");
                return;
            }

            ItemPos src = new(packet.SlotA, packet.ContainerSlotA);
            ItemPos destBagSlot = new(ItemSlot.Null, packet.ContainerSlotB);

            Item item = GetPlayer().GetItemByPos(src);
            if (item == null)
                return;

            if (!GetPlayer().IsValidPos(destBagSlot, false))      // can be autostore pos
            {
                GetPlayer().SendEquipError(InventoryResult.WrongSlot);
                return;
            }

            InventoryResult msg;
            // check unequip potability for equipped items and bank bags
            if (src.IsEquipmentPos || src.IsBagSlotPos)
            {
                msg = GetPlayer().CanUnequipItem(src, !src.IsBagSlotPos);
                if (msg != InventoryResult.Ok)
                {
                    GetPlayer().SendEquipError(msg, item);
                    return;
                }
            }

            msg = GetPlayer().CanStoreItem(destBagSlot, out List<(ItemPos item, int count)> dest, item);
            if (msg != InventoryResult.Ok)
            {
                GetPlayer().SendEquipError(msg, item);
                return;
            }

            // no-op: placed in same slot
            if (dest.Count == 1 && dest[0].item == src)
            {
                // just remove grey item state
                GetPlayer().SendEquipError(InventoryResult.InternalBagError, item);
                return;
            }

            GetPlayer().RemoveItem(src, true);
            GetPlayer().StoreItem(dest, item, true);
        }

        public void SendEnchantmentLog(ObjectGuid owner, ObjectGuid caster, ObjectGuid itemGuid, int itemId, int enchantId, EnchantmentSlot enchantSlot)
        {
            EnchantmentLog packet = new(); 
            packet.Owner = owner;
            packet.Caster = caster;
            packet.ItemGUID = itemGuid;
            packet.ItemID = itemId;
            packet.Enchantment = enchantId;
            packet.EnchantSlot = enchantSlot;

            GetPlayer().SendMessageToSet(packet, true);
        }

        public void SendItemEnchantTimeUpdate(ObjectGuid Playerguid, ObjectGuid Itemguid, EnchantmentSlot slot, uint Duration)
        {
            ItemEnchantTimeUpdate data = new();
            data.ItemGuid = Itemguid;
            data.DurationLeft = Duration;
            data.Slot = slot;
            data.OwnerGuid = Playerguid;
            SendPacket(data);
        }

        [WorldPacketHandler(ClientOpcodes.WrapItem)]
        void HandleWrapItem(WrapItem packet)
        {
            if (packet.Inv.Items.Count != 2)
            {
                Log.outError(LogFilter.Network, 
                    $"HandleWrapItem - Invalid itemCount ({packet.Inv.Items.Count})");
                return;
            }
            
            ItemPos giftPos = new(packet.Inv.Items[0].Slot, packet.Inv.Items[0].Container);            
            ItemPos itemPos = new(packet.Inv.Items[1].Slot, packet.Inv.Items[1].Container);

            Item gift = GetPlayer().GetItemByPos(giftPos);
            if (gift == null)
            {
                GetPlayer().SendEquipError(InventoryResult.ItemNotFound, gift);
                return;
            }

            if (!gift.GetTemplate().HasFlag(ItemFlags.IsWrapper)) // cheating: non-wrapper wrapper
            {
                GetPlayer().SendEquipError(InventoryResult.ItemNotFound, gift);
                return;
            }

            Item item = GetPlayer().GetItemByPos(itemPos);
            if (item == null)
            {
                GetPlayer().SendEquipError(InventoryResult.ItemNotFound, item);
                return;
            }

            if (item == gift) // not possible with packet from real client
            {
                GetPlayer().SendEquipError(InventoryResult.CantWrapWrapped, item);
                return;
            }

            if (item.IsEquipped())
            {
                GetPlayer().SendEquipError(InventoryResult.CantWrapEquipped, item);
                return;
            }

            if (!item.GetGiftCreator().IsEmpty()) // HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAGS_WRAPPED);
            {
                GetPlayer().SendEquipError(InventoryResult.CantWrapWrapped, item);
                return;
            }

            if (item.IsBag())
            {
                GetPlayer().SendEquipError(InventoryResult.CantWrapBags, item);
                return;
            }

            if (item.IsSoulBound())
            {
                GetPlayer().SendEquipError(InventoryResult.CantWrapBound, item);
                return;
            }

            if (item.GetMaxStackCount() != 1)
            {
                GetPlayer().SendEquipError(InventoryResult.CantWrapStackable, item);
                return;
            }

            // maybe not correct check  (it is better than nothing)
            if (item.GetTemplate().GetMaxCount() > 0)
            {
                GetPlayer().SendEquipError(InventoryResult.CantWrapUnique, item);
                return;
            }

            SQLTransaction trans = new();

            PreparedStatement stmt = CharacterDatabase.GetPreparedStatement(CharStatements.INS_CHAR_GIFT);
            stmt.SetInt64(0, item.GetOwnerGUID().GetCounter());
            stmt.SetInt64(1, item.GetGUID().GetCounter());
            stmt.SetInt32(2, item.GetEntry());
            stmt.SetUInt32(3, (uint)item.m_itemData.DynamicFlags);
            trans.Append(stmt);

            item.SetEntry(gift.GetEntry());

            switch (item.GetEntry())
            {
                case 5042:
                    item.SetEntry(5043);
                    break;
                case 5048:
                    item.SetEntry(5044);
                    break;
                case 17303:
                    item.SetEntry(17302);
                    break;
                case 17304:
                    item.SetEntry(17305);
                    break;
                case 17307:
                    item.SetEntry(17308);
                    break;
                case 21830:
                    item.SetEntry(21831);
                    break;
            }

            item.SetGiftCreator(GetPlayer().GetGUID());
            item.ReplaceAllItemFlags(ItemFieldFlags.Wrapped);
            item.SetState(ItemUpdateState.Changed, GetPlayer());

            if (item.GetState() == ItemUpdateState.New) // save new item, to have alway for `character_gifts` record in `item_instance`
            {
                // after save it will be impossible to remove the item from the queue
                Item.RemoveItemFromUpdateQueueOf(item, GetPlayer());
                item.SaveToDB(trans); // item gave inventory record unchanged and can be save standalone
            }
            DB.Characters.CommitTransaction(trans);

            int count = 1;
            GetPlayer().DestroyItemCount(gift, ref count, true);
        }

        [WorldPacketHandler(ClientOpcodes.SocketGems, Processing = PacketProcessing.Inplace)]
        void HandleSocketGems(SocketGems socketGems)
        {
            if (socketGems.ItemGuid.IsEmpty())
                return;

            //cheat . tried to socket same gem multiple times
            if ((!socketGems.GemItem[0].IsEmpty() && (socketGems.GemItem[0] == socketGems.GemItem[1] || socketGems.GemItem[0] == socketGems.GemItem[2])) ||
                (!socketGems.GemItem[1].IsEmpty() && (socketGems.GemItem[1] == socketGems.GemItem[2])))
                return;

            Item itemTarget = GetPlayer().GetItemByGuid(socketGems.ItemGuid);
            if (itemTarget == null)                                         //missing item to socket
                return;

            ItemTemplate itemProto = itemTarget.GetTemplate();
            if (itemProto == null)
                return;

            //this slot is excepted when applying / removing meta gem bonus
            var slot = itemTarget.IsEquipped() ? itemTarget.InventorySlot : ItemSlot.Null;

            var gems = new Item[ItemConst.MaxGemSockets];
            var gemData = new ItemDynamicFieldGems[ItemConst.MaxGemSockets];
            var gemProperties = new GemPropertiesRecord[ItemConst.MaxGemSockets];
            var oldGemData = new SocketedGem[ItemConst.MaxGemSockets];

            for (int i = 0; i < ItemConst.MaxGemSockets; ++i)
            {
                Item gem = _player.GetItemByGuid(socketGems.GemItem[i]);
                if (gem != null)
                {
                    gems[i] = gem;
                    gemData[i].ItemId = gem.GetEntry();
                    gemData[i].Context = (byte)gem.m_itemData.Context;

                    gemProperties[i] = CliDB.GemPropertiesStorage.LookupByKey(gem.GetTemplate().GetGemProperties());
                }

                oldGemData[i] = itemTarget.GetGem(i);
            }

            //There can only be one enchanted prismatic socket (SocketType.None + EnchantmentSlot.EnhancementSocketPrismatic)
            int? enchantedPrismaticSocket = null;

            for (int i = 0; i < ItemConst.MaxGemSockets; ++i)
            {
                if (gemProperties[i] == null)
                    continue;

                // tried to put gem in socket where no socket exists (take care about enchanted prismatic sockets)
                if (itemTarget.GetSocketType(i) == SocketType.None)
                {
                    // no enchanted prismatic socket
                    if (itemTarget.GetEnchantmentId(EnchantmentSlot.EnhancementSocketPrismatic) == 0)
                        return;

                    // already has enchanted prismatic socket
                    if (enchantedPrismaticSocket.HasValue)
                        return;

                    enchantedPrismaticSocket = i;
                }

                // Gem must match socket type
                var socketType =
                    (enchantedPrismaticSocket.HasValue && enchantedPrismaticSocket.Value == i) ?
                    SocketType.Prismatic :
                    itemTarget.GetSocketType(i);

                if (!gemProperties[i].Color.DoesMatchType(socketType))
                    return;
            }

            // check unique-equipped conditions
            for (int i = 0; i < ItemConst.MaxGemSockets; ++i)
            {
                if (gems[i] == null)
                    continue;

                // continue check for case when attempt add 2 similar unique equipped gems in one item.
                ItemTemplate iGemProto = gems[i].GetTemplate();

                // unique item (for new and already placed bit removed enchantments
                if (iGemProto.HasFlag(ItemFlags.UniqueEquippable))
                {
                    for (int j = 0; j < ItemConst.MaxGemSockets; ++j)
                    {
                        if (i == j)                                    // skip self
                            continue;

                        if (gems[j] != null)
                        {
                            if (iGemProto.GetId() == gems[j].GetEntry())
                            {
                                GetPlayer().SendEquipError(InventoryResult.ItemUniqueEquippableSocketed, itemTarget);
                                return;
                            }
                        }
                        else if (oldGemData[j] != null)
                        {
                            if (iGemProto.GetId() == oldGemData[j].ItemId)
                            {
                                GetPlayer().SendEquipError(InventoryResult.ItemUniqueEquippableSocketed, itemTarget);
                                return;
                            }
                        }
                    }
                }

                // unique limit Type item
                int limit_newcount = 0;
                if (iGemProto.GetItemLimitCategory() != 0)
                {
                    ItemLimitCategoryRecord limitEntry = CliDB.ItemLimitCategoryStorage.LookupByKey(iGemProto.GetItemLimitCategory());
                    if (limitEntry != null)
                    {
                        // NOTE: limitEntry.mode is not checked because if item has limit then it is applied in equip case
                        for (int j = 0; j < ItemConst.MaxGemSockets; ++j)
                        {
                            if (gems[j] != null)
                            {
                                // new gem
                                if (iGemProto.GetItemLimitCategory() == gems[j].GetTemplate().GetItemLimitCategory())
                                    ++limit_newcount;
                            }
                            else if (oldGemData[j] != null)
                            {
                                // existing gem
                                ItemTemplate jProto = Global.ObjectMgr.GetItemTemplate(oldGemData[j].ItemId.GetValue());
                                if (jProto != null)
                                    if (iGemProto.GetItemLimitCategory() == jProto.GetItemLimitCategory())
                                        ++limit_newcount;
                            }
                        }

                        if (limit_newcount > 0 && limit_newcount > _player.GetItemLimitCategoryQuantity(limitEntry))
                        {
                            GetPlayer().SendEquipError(InventoryResult.ItemUniqueEquippableSocketed, itemTarget);
                            return;
                        }
                    }
                }

                // for equipped item check all equipment for duplicate equipped gems
                if (itemTarget.IsEquipped())
                {
                    InventoryResult res = GetPlayer().CanEquipUniqueItem(gems[i], slot, Math.Max(limit_newcount, 0));
                    if (res != 0)
                    {
                        GetPlayer().SendEquipError(res, itemTarget);
                        return;
                    }
                }
            }

            bool hadSocketBonusActive = itemTarget.HasAllSocketsFilledWithMatchingColors();    //save state of socketbonus
            GetPlayer().ToggleMetaGemsActive(slot, false);             //turn off all metagems (except for the target item)

            //if a meta gem is being equipped, all information has to be written to the item before testing if the conditions for the gem are met

            //remove ALL enchants
            for (EnchantmentSlot enchanmentSlot = EnchantmentSlot.EnhancementSocket; 
                enchanmentSlot < (EnchantmentSlot.EnhancementSocket + ItemConst.MaxGemSockets); 
                ++enchanmentSlot)
            {
                _player.ApplyEnchantment(itemTarget, enchanmentSlot, false);
            }

            for (ushort i = 0; i < ItemConst.MaxGemSockets; ++i)
            {
                if (gems[i] != null)
                {
                    itemTarget.SetGem(i, gemData[i]);

                    if (gemProperties[i] != null && gemProperties[i].EnchantId != 0)
                        itemTarget.SetEnchantment(EnchantmentSlot.EnhancementSocket + i, gemProperties[i].EnchantId, 0, 0, GetPlayer().GetGUID());

                    var gemCount = 1;
                    GetPlayer().DestroyItemCount(gems[i], ref gemCount, true);
                }
            }

            for (EnchantmentSlot enchanmentSlot = EnchantmentSlot.EnhancementSocket;
                enchanmentSlot < (EnchantmentSlot.EnhancementSocket + ItemConst.MaxGemSockets);
                ++enchanmentSlot)
            {
                _player.ApplyEnchantment(itemTarget, enchanmentSlot, true);           
            }

            bool SocketBonusToBeActivated = itemTarget.HasAllSocketsFilledWithMatchingColors();//current socketbonus state
            if (hadSocketBonusActive ^ SocketBonusToBeActivated)     //if there was a change...
            {
                GetPlayer().ApplyEnchantment(itemTarget, EnchantmentSlot.EnhancementSocketBonus, false);
                itemTarget.SetEnchantment(EnchantmentSlot.EnhancementSocketBonus, SocketBonusToBeActivated ? itemTarget.GetTemplate().GetSocketBonus() : 0, 0, 0, GetPlayer().GetGUID());
                GetPlayer().ApplyEnchantment(itemTarget, EnchantmentSlot.EnhancementSocketBonus, true);
                //it is not displayed, client has an inbuilt system to determine if the bonus is activated
            }

            GetPlayer().ToggleMetaGemsActive(slot, true);              //turn on all metagems (except for target item)

            GetPlayer().RemoveTradeableItem(itemTarget);
            itemTarget.ClearSoulboundTradeable(GetPlayer());           // clear tradeable flag

            itemTarget.SendUpdateSockets();
        }

        [WorldPacketHandler(ClientOpcodes.CancelTempEnchantment, Processing = PacketProcessing.Inplace)]
        void HandleCancelTempEnchantment(CancelTempEnchantment packet)
        {
            ItemPos itemWithEnch = (byte)packet.Slot;

            if (!itemWithEnch.IsEquipmentPos)
                return;

            Item item = GetPlayer().GetItemByPos(itemWithEnch);
            if (item == null)
                return;

            if (item.GetEnchantmentId(EnchantmentSlot.EnhancementTemporary) == 0)
                return;

            GetPlayer().ApplyEnchantment(item, EnchantmentSlot.EnhancementTemporary, false);
            item.ClearEnchantment(EnchantmentSlot.EnhancementTemporary);
        }

        [WorldPacketHandler(ClientOpcodes.GetItemPurchaseData, Processing = PacketProcessing.Inplace)]
        void HandleGetItemPurchaseData(GetItemPurchaseData packet)
        {
            Item item = GetPlayer().GetItemByGuid(packet.ItemGUID);
            if (item == null)
            {
                Log.outDebug(LogFilter.Network, 
                    $"HandleGetItemPurchaseData: Item {packet.ItemGUID} not found!");
                return;
            }

            GetPlayer().SendRefundInfo(item);
        }

        [WorldPacketHandler(ClientOpcodes.ItemPurchaseRefund, Processing = PacketProcessing.Inplace)]
        void HandleItemRefund(ItemPurchaseRefund packet)
        {
            Item item = GetPlayer().GetItemByGuid(packet.ItemGUID);
            if (item == null)
            {
                Log.outDebug(LogFilter.Network,
                    $"WorldSession.HandleItemRefund: Item {packet.ItemGUID} not found!");
                return;
            }

            // Don't try to refund item currently being disenchanted
            if (GetPlayer().GetLootGUID() == packet.ItemGUID)
                return;

            GetPlayer().RefundItem(item);
        }

        bool CanUseBank(ObjectGuid bankerGUID = default)
        {
            // bankerGUID parameter is optional, set to 0 by default.
            if (bankerGUID.IsEmpty())
                bankerGUID = _player.PlayerTalkClass.GetInteractionData().SourceGuid;

            bool isUsingBankCommand = bankerGUID == GetPlayer().GetGUID() && bankerGUID == _player.PlayerTalkClass.GetInteractionData().SourceGuid;

            if (!isUsingBankCommand)
            {
                Creature creature = GetPlayer().GetNPCIfCanInteractWith(bankerGUID, NPCFlags1.Banker, NPCFlags2.None);
                if (creature == null)
                    return false;
            }

            return true;
        }

        [WorldPacketHandler(ClientOpcodes.UseCritterItem)]
        void HandleUseCritterItem(UseCritterItem useCritterItem)
        {
            Item item = GetPlayer().GetItemByGuid(useCritterItem.ItemGuid);
            if (item == null)
                return;

            foreach (var itemEffect in item.GetEffects())
            {
                if (itemEffect.TriggerType != ItemSpelltriggerType.OnLearn)
                    continue;

                var speciesEntry = BattlePetMgr.GetBattlePetSpeciesBySpell(itemEffect.SpellID);
                if (speciesEntry != null)
                {
                    GetBattlePetMgr().AddPet(speciesEntry.Id, BattlePetMgr.SelectPetDisplay(speciesEntry),
                        BattlePetMgr.RollPetBreed(speciesEntry.Id), BattlePetMgr.GetDefaultPetQuality(speciesEntry.Id));
                }
            }

            GetPlayer().DestroyItem(item.InventoryPosition, true);
        }

        [WorldPacketHandler(ClientOpcodes.SortBags, Processing = PacketProcessing.Inplace)]
        void HandleSortBags(SortBags sortBags)
        {
            // TODO: Implement sorting
            // Placeholder to prevent completely locking out bags clientside
            SendPacket(new BagCleanupFinished());
        }

        [WorldPacketHandler(ClientOpcodes.SortBankBags, Processing = PacketProcessing.Inplace)]
        void HandleSortBankBags(SortBankBags sortBankBags)
        {
            // TODO: Implement sorting
            // Placeholder to prevent completely locking out bags clientside
            SendPacket(new BagCleanupFinished());
        }

        [WorldPacketHandler(ClientOpcodes.SortReagentBankBags, Processing = PacketProcessing.Inplace)]
        void HandleSortReagentBankBags(SortReagentBankBags sortReagentBankBags)
        {
            // TODO: Implement sorting
            // Placeholder to prevent completely locking out bags clientside
            SendPacket(new BagCleanupFinished());
        }

        [WorldPacketHandler(ClientOpcodes.RemoveNewItem, Processing = PacketProcessing.Inplace)]
        void HandleRemoveNewItem(RemoveNewItem removeNewItem)
        {
            Item item = _player.GetItemByGuid(removeNewItem.ItemGuid);
            if (item == null)
            {
                Log.outDebug(LogFilter.Network, 
                    $"WorldSession.HandleRemoveNewItem: " +
                    $"Item ({removeNewItem.ItemGuid}) not found for {GetPlayerInfo()}!");
                return;
            }

            if (item.HasItemFlag(ItemFieldFlags.NewItem))
            {
                item.RemoveItemFlag(ItemFieldFlags.NewItem);
                item.SetState(ItemUpdateState.Changed, _player);
            }
        }
    }
}
